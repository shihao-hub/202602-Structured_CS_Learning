# 指令系统 (Instruction Set)

## 408 考试映射

本模块涵盖计算机组成原理 408 考试中的指令系统相关内容。这是一个以概念为主的模块。

## 1. 指令格式

### 指令的组成
- **操作码字段（Opcode）**：指明操作的性质和功能
- **地址码字段（Address）**：指明操作数的来源和结果的去向

### 按地址码数量分类

#### 零地址指令
```
OP
```
- 无地址码，用于栈式计算机
- 操作数隐含在栈顶
- 例：`PUSH`, `POP`, `ADD`（隐含栈顶两元素相加）

#### 一地址指令
```
OP | A1
```
- 一个显式地址，另一个操作数隐含在累加器 ACC
- 格式：`(ACC) OP (A1) → ACC`
- 例：`ADD R1`（ACC ← ACC + R1）

#### 二地址指令
```
OP | A1 | A2
```
- 两个地址码，目的地址和源地址之一重叠
- 格式：`(A1) OP (A2) → A1`
- 例：`ADD R1, R2`（R1 ← R1 + R2）
- **最常用的指令格式**

#### 三地址指令
```
OP | A1 | A2 | A3
```
- 三个地址码，两个源操作数和一个目的操作数
- 格式：`(A1) OP (A2) → A3`
- 例：`ADD R1, R2, R3`（R3 ← R1 + R2）
- 功能强大但指令字长较长

### 指令字长的权衡
- **定长指令字**：指令长度固定，便于取指和译码，但灵活性差
- **变长指令字**：指令长度可变，节省存储空间，但硬件复杂

## 2. 寻址方式

寻址方式决定了如何从指令中获取操作数的地址。这是 408 考试的重点！

### 2.1 立即寻址（Immediate Addressing）
```
指令格式: OP | #D
有效地址: 无
操作数:   D（立即数）
```
- **特点**：操作数直接在指令中给出
- **优点**：无需访存，速度最快
- **缺点**：操作数范围受指令字长限制
- **例**：`MOV R1, #100`（R1 ← 100）

### 2.2 直接寻址（Direct Addressing）
```
指令格式: OP | A
有效地址: EA = A
操作数:   (A)
```
- **特点**：指令中直接给出操作数的地址
- **优点**：简单，只需访存一次
- **缺点**：地址范围受指令字长限制，不便于程序浮动
- **例**：`MOV R1, [1000]`（R1 ← M[1000]）

### 2.3 间接寻址（Indirect Addressing）
```
指令格式: OP | @A
有效地址: EA = (A)
操作数:   ((A))
```
- **特点**：指令中给出的地址指向存放操作数地址的单元
- **优点**：寻址范围扩大，便于访问更大的地址空间
- **缺点**：需要两次访存，速度慢
- **例**：`MOV R1, @[1000]`（R1 ← M[M[1000]]）

#### 多级间接寻址
可以多次间接，直到最高位标志位为 0
```
一次间接: EA = (A)
二次间接: EA = ((A))
...
```

### 2.4 寄存器寻址（Register Addressing）
```
指令格式: OP | Ri
有效地址: 无
操作数:   (Ri)
```
- **特点**：操作数在寄存器中
- **优点**：不需访存，速度仅次于立即寻址；指令字短
- **缺点**：寄存器数量有限
- **例**：`MOV R1, R2`（R1 ← R2）

### 2.5 寄存器间接寻址（Register Indirect Addressing）
```
指令格式: OP | (Ri)
有效地址: EA = (Ri)
操作数:   ((Ri))
```
- **特点**：寄存器中存放操作数的地址
- **优点**：寻址范围大（取决于寄存器位数），便于循环和数组访问
- **缺点**：需要一次访存
- **例**：`MOV R1, (R2)`（R1 ← M[R2]）

### 2.6 相对寻址（Relative Addressing）
```
指令格式: OP | D
有效地址: EA = (PC) + D
操作数:   (EA)
```
- **特点**：有效地址 = 程序计数器 PC + 位移量 D
- **优点**：便于程序浮动，用于转移指令
- **缺点**：寻址范围受位移量字长限制
- **例**：`JMP +10`（跳转到 PC+10）
- **注意**：PC 值为当前指令地址或下一条指令地址（与机器相关）

### 2.7 基址寻址（Base Addressing）
```
指令格式: OP | BR | D
有效地址: EA = (BR) + D
操作数:   (EA)
```
- **特点**：有效地址 = 基址寄存器 + 位移量
- **优点**：便于程序浮动和多道程序；扩大寻址范围
- **用途**：实现分段存储管理
- **基址寄存器**：由操作系统管理，用户不可见或不能改变
- **例**：`MOV R1, [BR+100]`（R1 ← M[BR+100]）

### 2.8 变址寻址（Indexed Addressing）
```
指令格式: OP | IX | D
有效地址: EA = (IX) + D
操作数:   (EA)
```
- **特点**：有效地址 = 变址寄存器 + 位移量（通常是指令地址码）
- **优点**：便于访问数组、字符串；循环程序
- **变址寄存器**：用户可见，可由程序改变
- **例**：`MOV R1, [IX+array]`（访问数组元素）

#### 基址与变址的区别
| 特性 | 基址寻址 | 变址寻址 |
|------|---------|---------|
| 寄存器值 | 基址寄存器由系统设置 | 变址寄存器由用户设置 |
| 变化部分 | 位移量（指令中） | 变址寄存器（程序中） |
| 主要用途 | 程序浮动、多道程序 | 数组访问、循环 |

### 2.9 堆栈寻址（Stack Addressing）
```
隐含寻址: 栈顶由 SP (Stack Pointer) 指出
操作:     PUSH、POP
```
- **特点**：后进先出（LIFO）
- **栈顶指针 SP**：指向栈顶元素或下一个空位（与机器相关）
- **用途**：子程序调用、中断处理、表达式求值

## 3. CISC 与 RISC

### CISC (Complex Instruction Set Computer) 复杂指令集
- **特点**：
  - 指令数量多，功能强大，变长指令
  - 支持多种寻址方式
  - 微程序控制，复杂度在硬件
- **代表**：Intel x86
- **优点**：编译器简单，代码密度高
- **缺点**：硬件复杂，功耗高，不利于流水线

### RISC (Reduced Instruction Set Computer) 精简指令集
- **特点**：
  - 指令数量少，格式规整，定长指令
  - 寻址方式少，大多数指令为单周期
  - 硬布线控制，大量使用寄存器
  - Load/Store 结构：只有 Load/Store 访存
- **代表**：ARM, MIPS, RISC-V
- **优点**：便于流水线实现，功耗低，性能高
- **缺点**：代码密度低，编译器复杂

### CISC vs RISC 对比表

| 特性 | CISC | RISC |
|------|------|------|
| 指令数量 | 多 (200-300) | 少 (50-100) |
| 指令格式 | 变长 | 定长 |
| 寻址方式 | 多 (10+) | 少 (3-5) |
| 指令功能 | 复杂 | 简单 |
| CPI | 2-15 | ~1 |
| 寄存器 | 少 | 多 |
| 控制方式 | 微程序 | 硬布线 |
| 访存指令 | 任意指令 | 仅 Load/Store |
| 流水线 | 困难 | 容易 |
| 编译器 | 简单 | 复杂 |
| 代码密度 | 高 | 低 |

## 4. 指令执行周期

### 指令执行的基本步骤
1. **取指（IF - Instruction Fetch）**
   - PC → MAR → M → MDR → IR
   - (PC) + 1 → PC

2. **译码（ID - Instruction Decode）**
   - 分析指令操作码
   - 读取源操作数

3. **执行（EX - Execute）**
   - ALU 执行运算

4. **访存（MEM - Memory Access）**
   - 读/写内存（如果需要）

5. **写回（WB - Write Back）**
   - 结果写回寄存器或内存

## 5. 408 考试重点总结

### 常考题型

#### 1. 寻址方式计算题
给定指令和寄存器/内存状态，计算有效地址和操作数。

**例题**：
```
已知：PC = 1000H, R1 = 2000H, M[2000H] = 3000H, M[3000H] = 50
求下列指令的操作数：
(1) MOV R0, #100         立即寻址: 操作数 = 100
(2) MOV R0, [2000H]      直接寻址: 操作数 = M[2000H] = 3000H
(3) MOV R0, @[2000H]     间接寻址: 操作数 = M[M[2000H]] = M[3000H] = 50
(4) MOV R0, (R1)         寄存器间接: 操作数 = M[R1] = M[2000H] = 3000H
(5) MOV R0, [PC+100H]    相对寻址: EA = 1000H + 100H = 1100H
```

#### 2. 指令格式分析
- 计算不同地址码数量的指令执行次数
- 分析指令字长与寻址范围的关系

#### 3. CISC vs RISC 对比
- 理解两种架构的设计思想
- 分析各自的优缺点和适用场景

### 必记公式

1. **指令执行时间**
   ```
   T = 指令数 × CPI × 时钟周期
   ```

2. **不同地址码指令的执行次数**（计算 C = A + B）
   - 三地址：1 条（`ADD A, B, C`）
   - 二地址：2 条（`MOV C, A; ADD C, B`）
   - 一地址：3 条（`LOAD A; ADD B; STORE C`）
   - 零地址：4 条（`PUSH A; PUSH B; ADD; POP C`）

3. **寻址范围**
   - 直接寻址：2^n（n 为地址码位数）
   - 间接寻址：2^m（m 为存储字长）
   - 相对寻址：PC ± 2^(n-1)（n 为位移量位数）

### 记忆技巧

**寻址方式速度排序**（从快到慢）：
```
立即寻址 > 寄存器寻址 > 直接寻址 > 寄存器间接 > 间接寻址
     0次访存    0次访存    1次访存      1次访存      2次访存
```

**寻址方式应用场景**：
- 立即数 → 立即寻址
- 变量 → 直接寻址
- 指针 → 间接寻址
- 数组 → 变址寻址
- 局部变量 → 基址寻址（栈帧）
- 跳转 → 相对寻址

## 文件说明

- `instruction.go` - 指令格式和寻址方式的基本实现
- `example.go` - 示例程序入口

## 运行示例

```go
package main

import "Structured_CS_Learning/CS_Core_Courses/computer_architecture/instruction_set"

func main() {
    instruction_set.RunAllInstructionSetExamples()
}
```
